import json
import os
import time
from pathlib import Path

import openai
import pandas as pd
import PyPDF2

from src.prompts.llm_prompt import get_prompt
from src.utils import load_env_var


class KnowledgeExtractor:
    def __init__(self, config):
        """
        Initialize the KnowledgeExtractor object.

        Args:
        - config (dict): Configuration dictionary from `config.yaml`.
        """
        self.pdf_folder = Path(config["download"]["pdf_folder"])
        self.output_folder = Path(config["llm"]["output_folder"])
        self.merged_output_file = Path(config["llm"]["merged_responses_file"])
        self.delay = config["llm"]["delay"]

        # Load API key from the environment variable
        self.api_key = load_env_var("OPENAI_API_KEY")

        if not self.api_key:
            raise ValueError("OPENAI_API_KEY is not set in the environment.")
        openai.api_key = self.api_key

        # Ensure output folder exists
        self.output_folder.mkdir(parents=True, exist_ok=True)

        # Check if PDF folder exists
        if not self.pdf_folder.exists():
            raise FileNotFoundError(f"PDF folder not found: {self.pdf_folder}")

    def extract_text_from_pdf(self, pdf_path):
        """
        Extracts text from a PDF file.

        Args:
        - pdf_path (Path): Path to the PDF file.

        Returns:
        - str: Extracted text.
        """
        try:
            with open(pdf_path, "rb") as file:
                reader = PyPDF2.PdfReader(file)
                text = ""
                for page in reader.pages:
                    text += page.extract_text()
                return text
        except Exception as e:
            print(f"Error reading PDF {pdf_path}: {e}")
            return ""

    def parse_json_output(self, json_string):
        """
        Parses and validates the JSON output.

        Args:
        - json_string (str): JSON string generated by the API.

        Returns:
        - dict: Parsed JSON as a dictionary if valid.
        - None: If the JSON is invalid or incomplete.
        """
        try:
            # Clean the output: Remove ```json and ``` markers
            if json_string.startswith("```json"):
                json_string = json_string[7:]  # Remove ```json
            if json_string.endswith("```"):
                json_string = json_string[:-3]  # Remove closing ```

            parsed_json = json.loads(json_string)
            # Add additional validation rules here if needed
            return parsed_json
        except json.JSONDecodeError as e:
            print(f"Invalid JSON format: {e}")
            return None

    def generate_structured_json(self, pdf_text):
        """
        Sends the extracted PDF text to OpenAI API with the prompt and generates a structured JSON.

        Args:
        - pdf_text (str): The text extracted from the PDF.

        Returns:
        - dict: Parsed JSON output from the model.
        """
        prompt = get_prompt(pdf_text)

        # print(prompt)
        try:
            response = openai.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {
                        "role": "system",
                        "content": "You are a professional research assistant.",
                    },
                    {"role": "user", "content": prompt},
                ],
            )
            return response.choices[0].message.content.strip()
        except Exception as e:
            print(f"Error with OpenAI API: {e}")
            return None

    def process_pdf(self, pdf_path):
        """
        Process a single PDF file: Extracts text, generates JSON response, and parses the JSON.

        Args:
        - pdf_path (Path): Path to the PDF file.

        Returns:
        - dict: Parsed and validated JSON response.
        """
        print(f"Processing {pdf_path.name}...")
        pdf_text = self.extract_text_from_pdf(pdf_path)
        if not pdf_text.strip():
            print(f"Skipping {pdf_path.name} (No text extracted).")
            return None

        raw_json = self.generate_structured_json(pdf_text)
        if not raw_json:
            print(f"Skipping {pdf_path.name} (No JSON generated).")
            return None

        parsed_json = self.parse_json_output(raw_json)
        if not parsed_json:
            print(f"Skipping {pdf_path.name} (Invalid JSON format).")
            return None

        return parsed_json

    def process_all_pdfs(self):
        """
        Process all PDF files in the folder, validate JSON, and save the responses as structured JSON files.
        """
        all_responses = []

        for pdf_file in self.pdf_folder.glob("*.pdf"):
            paper_id = pdf_file.stem
            output_file = self.output_folder / f"{paper_id}.json"

            if output_file.exists():
                print(f"Skipping {pdf_file.name} (Already processed).")
                continue

            llm_data = self.process_pdf(pdf_file)
            if llm_data:
                all_responses.append({"paper_id": paper_id, **llm_data})

                try:
                    with open(output_file, "w", encoding="utf-8") as f:
                        json.dump(llm_data, f, indent=4)
                    print(
                        f"Saved structured JSON for {pdf_file.name} to {output_file}."
                    )
                except Exception as e:
                    print(f"Error saving JSON for {pdf_file.name}: {e}")

            # Add a delay between processing files
            print(
                f"Waiting for {self.delay} seconds before processing the next file..."
            )
            time.sleep(self.delay)

        # Save the merged JSON file
        try:
            with open(self.merged_output_file, "w", encoding="utf-8") as merged_file:
                json.dump(all_responses, merged_file, indent=4)
            print(f"Merged all LLM responses into {self.merged_output_file}")
        except Exception as e:
            print(f"Error saving merged JSON file: {e}")
